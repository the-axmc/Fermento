"use client";

import React, { useState } from "react";
import { Layout, Button, Input, Textarea, Card } from "@stellar/design-system";

// Generated by `stellar scaffold watch --build-clients`
import * as nonFungible from "../contracts/non_fungible_contract";

// Wallet hook (shape varies by lib)
import { useWallet } from "../hooks/useWallet";

/* ---------------------------------- Types --------------------------------- */

type FermentationState = "active" | "monitoring" | "ready";

interface FermentationProduct {
  id: string;          // local UI id
  tokenId: number;     // on-chain u32 id
  name: string;
  type: string;
  startDate: string;
  currentState: FermentationState;
  progress: number;    // 0..100
  metadata: {
    ingredients: string;
    temperature: string;
    notes: string;
  };
  progressLog: Array<{ date: string; state: string; notes: string }>;
}

/** Contract method signatures (common scaffold variants) */
type MintArgs = { to: string; token_id: number; uri: string; caller?: string };
type SetMetaArgs = { token_id: number; uri: string; caller?: string };
type BurnArgs = { token_id: number; caller?: string };

type NftContract = {
  mint?: (args: MintArgs) => Promise<unknown>;
  mint_to?: (args: MintArgs) => Promise<unknown>;
  set_metadata?: (args: SetMetaArgs) => Promise<unknown>;
  set_uri?: (args: SetMetaArgs) => Promise<unknown>;
  burn?: (args: BurnArgs) => Promise<unknown>;
};

/* ------------------------------- Util helpers ------------------------------ */

const todayISO = () => new Date().toISOString().split("T")[0];
const clamp = (n: number, lo: number, hi: number) => Math.min(hi, Math.max(lo, n));
const toU32 = (n: number) => clamp(Math.floor(Number.isFinite(n) ? n : 0), 0, 0xffffffff);
const newTokenId = () => toU32(Date.now() % 0x7fffffff);

const errorToString = (e: unknown): string => {
  if (e instanceof Error && typeof e.message === "string") return e.message;
  if (typeof e === "string") return e;
  try { return JSON.stringify(e); } catch { return String(e); }
};

const isRecord = (v: unknown): v is Record<string, unknown> => typeof v === "object" && v !== null;
const getStringProp = (o: Record<string, unknown>, k: string) => (typeof o[k] === "string" ? (o[k] as string) : undefined);

const extractPublicKey = (wallet: unknown): string | undefined => {
  if (!isRecord(wallet)) return undefined;
  const direct = getStringProp(wallet, "publicKey") ?? getStringProp(wallet, "address") ?? getStringProp(wallet, "accountId");
  if (direct) return direct;
  const acct = isRecord(wallet.account) ? (wallet.account as Record<string, unknown>) : undefined;
  return (acct && getStringProp(acct, "publicKey")) || undefined;
};

const getNftContract = (): NftContract => {
  const mod = nonFungible as unknown as { default?: unknown } & Record<string, unknown>;
  return (mod.default ?? mod) as NftContract;
};

const makeMetadataURI = (p: FermentationProduct): string => {
  const payload = {
    name: p.name,
    category: p.type,
    startedAt: p.startDate,
    state: p.currentState,
    progress: p.progress,
    attributes: {
      ingredients: p.metadata.ingredients,
      temperature: p.metadata.temperature,
      notes: p.metadata.notes,
    },
    log: p.progressLog,
    updatedAt: new Date().toISOString(),
  };
  return `data:application/json,${encodeURIComponent(JSON.stringify(payload))}`;
};

async function callMaybeWithCaller<T extends object, R>(
  fn: ((args: T & { caller?: string }) => Promise<R>) | undefined,
  args: T,
  caller?: string,
): Promise<R | undefined> {
  if (!fn) return undefined as unknown as R;
  try {
    if (caller) return await fn({ ...(args as object), caller } as T & { caller?: string });
    return await fn({ ...(args as object) } as T & { caller?: string });
  } catch (e) {
    const msg = errorToString(e).toLowerCase();
    const unknownField = msg.includes("unknown") && msg.includes("field") && msg.includes("caller");
    const missingField = msg.includes("missing") && msg.includes("field") && msg.includes("caller");
    if (caller && unknownField) return await fn({ ...(args as object) } as T & { caller?: string });
    if (!caller && missingField) throw new Error("Contract requires `caller` arg. Connect wallet and pass your address.");
    throw e;
  }
}

/* --------------------------------- Styles ---------------------------------- */

const labelCss: React.CSSProperties = { color: "#6b7280", fontSize: 12, fontWeight: 500 };
const cardBox: React.CSSProperties = { border: "1px solid #e5e7eb", borderRadius: 12, background: "#fff", padding: 16, margin: "16px 0" };
const listGap: React.CSSProperties = { display: "grid", gap: 12 };

/* --------------------------------- Component ------------------------------- */

const Catalogue: React.FC = () => {
  const wallet = useWallet();
  const walletPublicKey = extractPublicKey(wallet);
  const isConnected = typeof walletPublicKey === "string" && walletPublicKey.length > 0;

  const [items, setItems] = useState<FermentationProduct[]>([]);
  const [isAdding, setIsAdding] = useState(false);
  const [mintOnAdd, setMintOnAdd] = useState(true);

  const [form, setForm] = useState({
    name: "",
    type: "",
    ingredients: "",
    temperature: "",
    notes: "",
  });

  const resetForm = () => setForm({ name: "", type: "", ingredients: "", temperature: "", notes: "" });

  /* ----------------------------- On-chain actions --------------------------- */

  const mintP1 = async (p: FermentationProduct) => {
    const c = getNftContract();
    const uri = makeMetadataURI(p);
    try {
      const minted =
        (await callMaybeWithCaller(c.mint, { to: walletPublicKey!, token_id: p.tokenId, uri }, walletPublicKey)) ??
        (await callMaybeWithCaller(c.mint_to, { to: walletPublicKey!, token_id: p.tokenId, uri }, walletPublicKey));
      if (!minted) alert("Contract has no mint/mint_to; cannot mint on-chain yet.");
    } catch (err: unknown) {
      // eslint-disable-next-line no-console
      console.error(err);
      alert(`Mint failed: ${errorToString(err)}`);
    }
  };

  const updateOnChainMetadata = async (p: FermentationProduct) => {
    const c = getNftContract();
    const uri = makeMetadataURI(p);
    try {
      await callMaybeWithCaller(c.set_metadata, { token_id: p.tokenId, uri }, walletPublicKey);
      await callMaybeWithCaller(c.set_uri, { token_id: p.tokenId, uri }, walletPublicKey);
    } catch (err) {
      // optional; don't block UX
      // eslint-disable-next-line no-console
      console.warn("Metadata update failed:", err);
    }
  };

  const transformP1toP2 = async (p1: FermentationProduct) => {
    const c = getNftContract();
    try {
      await callMaybeWithCaller(c.burn, { token_id: p1.tokenId }, walletPublicKey);
      const p2: FermentationProduct = {
        ...p1,
        tokenId: toU32(p1.tokenId + 1),
        currentState: "ready",
        progress: 100,
        progressLog: [...p1.progressLog, { date: todayISO(), state: "Transformed to P2 (ready)", notes: "Fermentation completed" }],
      };
      const uri2 = makeMetadataURI(p2);
      const mintedP2 =
        (await callMaybeWithCaller(c.mint, { to: walletPublicKey!, token_id: p2.tokenId, uri: uri2 }, walletPublicKey)) ??
        (await callMaybeWithCaller(c.mint_to, { to: walletPublicKey!, token_id: p2.tokenId, uri: uri2 }, walletPublicKey));
      if (!mintedP2) {
        alert("Contract has no mint/mint_to; cannot mint P2.");
        return;
      }
      setItems((prev) => prev.map((x) => (x.id === p1.id ? p2 : x)));
      alert("ðŸŽ‰ Fermentation completed: P1 burned (if supported) and P2 minted.");
    } catch (err: unknown) {
      // eslint-disable-next-line no-console
      console.error(err);
      alert(`Finalize failed: ${errorToString(err)}`);
    }
  };

  /* -------------------------------- Handlers -------------------------------- */

  const onSave = async () => {
    if (!form.name.trim() || !form.type.trim()) {
      alert("Name and Type are required.");
      return;
    }

    const product: FermentationProduct = {
      id: String(Date.now()),
      tokenId: newTokenId(),
      name: form.name.trim(),
      type: form.type.trim(),
      startDate: todayISO(),
      currentState: "active",
      progress: 0,
      metadata: {
        ingredients: form.ingredients.trim(),
        temperature: form.temperature.trim(),
        notes: form.notes.trim(),
      },
      progressLog: [{ date: todayISO(), state: "Started", notes: "Initial setup" }],
    };

    setItems((prev) => [product, ...prev]);
    setIsAdding(false);
    resetForm();

    if (mintOnAdd) {
      if (!isConnected) {
        alert("Connect wallet to mint on-chain.");
        return;
      }
      await mintP1(product);
    }
  };

  const bumpProgress = async (id: string, delta: number, note: string) => {
    let updated: FermentationProduct | undefined;
    setItems((prev) =>
      prev.map((p) => {
        if (p.id !== id) return p;
        const pct = clamp(p.progress + delta, 0, 100);
        const state: FermentationState = pct >= 100 ? "ready" : pct >= 50 ? "monitoring" : "active";
        updated = { ...p, progress: pct, currentState: state, progressLog: [...p.progressLog, { date: todayISO(), state: `Progress: ${pct}%`, notes: note }] };
        return updated!;
      }),
    );
    if (updated && isConnected) await updateOnChainMetadata(updated);
  };

  /* ---------------------------------- UI ------------------------------------ */

  const Label: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <div style={labelCss}>{children}</div>
  );

  return (
    <Layout.Content>
      <Layout.Inset>
        <h1 style={{ marginTop: 0 }}>Catalogue</h1>
        <p style={{ color: "#6b7280" }}>
          1) Add a product (fills metadata for P1). 2) Save (optionally mint P1). 3) Update progress. 4) At 100%,
          complete fermentation â†’ burn P1 (if supported) and mint P2.
        </p>

        {/* Add form */}
        <div style={cardBox}>
          {/* using Card without style, and wrapping for layout safety */}
          <Card>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <h3 style={{ margin: 0 }}>New Product</h3>
              <Button variant={isAdding ? "tertiary" : "primary"} size="sm" onClick={() => setIsAdding((s) => !s)}>
                {isAdding ? "Close" : "Open form"}
              </Button>
            </div>

            {isAdding && (
              <div style={{ display: "grid", gap: 12, marginTop: 12 }}>
                <Input
                  id="name"
                  label="Product Name"
                  fieldSize="md"
                  value={form.name}
                  onChange={(e) => setForm((f) => ({ ...f, name: e.target.value }))}
                  placeholder="e.g., Sourdough Starter"
                />

                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12 }}>
                  <Input
                    id="type"
                    label="Type"
                    fieldSize="md"
                    value={form.type}
                    onChange={(e) => setForm((f) => ({ ...f, type: e.target.value }))}
                    placeholder="Bread / Vegetable / Dairy / Beverage / Other"
                  />
                  <Input
                    id="temperature"
                    label="Temperature"
                    fieldSize="md"
                    value={form.temperature}
                    onChange={(e) => setForm((f) => ({ ...f, temperature: e.target.value }))}
                    placeholder="e.g., 22Â°C"
                  />
                </div>

                <Input
                  id="ingredients"
                  label="Ingredients"
                  fieldSize="md"
                  value={form.ingredients}
                  onChange={(e) => setForm((f) => ({ ...f, ingredients: e.target.value }))}
                  placeholder="Main ingredients"
                />

                <Textarea
                  id="notes"
                  label="Notes"
                  fieldSize="md"
                  value={form.notes}
                  onChange={(e) => setForm((f) => ({ ...f, notes: e.target.value }))}
                  placeholder="Additional notes..."
                />

                <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                  <input
                    id="mintOnAdd"
                    type="checkbox"
                    checked={mintOnAdd}
                    onChange={(e) => setMintOnAdd(e.target.checked)}
                  />
                  <label htmlFor="mintOnAdd" style={{ fontSize: 14 }}>
                    Mint NFT on save
                  </label>
                  {!isConnected && mintOnAdd && (
                    <span style={{ color: "#ef4444", fontSize: 12, marginLeft: 8 }}>
                      (Connect wallet to mint)
                    </span>
                  )}
                </div>

                <Button variant="primary" size="md" onClick={() => void onSave()}>
                  Save{mintOnAdd ? " & Mint P1" : ""}
                </Button>
              </div>
            )}
          </Card>
        </div>

        {/* List */}
        <div style={listGap}>
          {items.map((p) => (
            <div key={p.id} style={cardBox}>
              <Card>
                <div style={{ display: "flex", justifyContent: "space-between", alignItems: "baseline" }}>
                  <h3 style={{ margin: 0 }}>{p.name}</h3>
                  <div style={{ color: "#6b7280", fontSize: 12 }}>
                    {p.type} â€¢ token #{p.tokenId} â€¢ started {p.startDate}
                  </div>
                </div>

                <div style={{ marginTop: 8, display: "grid", gridTemplateColumns: "repeat(2, minmax(0,1fr))", gap: 12 }}>
                  <div>
                    <Label>State</Label>
                    <div>{p.currentState}</div>
                  </div>
                  <div>
                    <Label>Progress</Label>
                    <div>{p.progress}%</div>
                  </div>
                  <div>
                    <Label>Temperature</Label>
                    <div>{p.metadata.temperature}</div>
                  </div>
                  <div>
                    <Label>Ingredients</Label>
                    <div>{p.metadata.ingredients}</div>
                  </div>
                </div>

                <div style={{ display: "flex", gap: 8, marginTop: 12, flexWrap: "wrap" }}>
                  <Button variant="tertiary" size="sm" onClick={() => void bumpProgress(p.id, +10, "Progress +10%")}>
                    +10%
                  </Button>
                  <Button variant="tertiary" size="sm" onClick={() => void bumpProgress(p.id, +25, "Progress +25%")}>
                    +25%
                  </Button>
                  <Button variant="tertiary" size="sm" onClick={() => void bumpProgress(p.id, 100 - p.progress, "Completed")}>
                    Set 100%
                  </Button>
                  {p.currentState === "ready" && (
                    <Button variant="primary" size="sm" onClick={() => void transformP1toP2(p)}>
                      Complete fermentation (P1 â†’ P2)
                    </Button>
                  )}
                </div>
              </Card>
            </div>
          ))}

          {items.length === 0 && (
            <div style={cardBox}>
              <Card>
                <div style={{ textAlign: "center", color: "#6b7280" }}>
                  No products yet. Add your first one above.
                </div>
              </Card>
            </div>
          )}
        </div>
      </Layout.Inset>
    </Layout.Content>
  );
};

export default Catalogue;
