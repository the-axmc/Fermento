"use client";

import React from "react";
import { Layout } from "@stellar/design-system";

// Generated by `stellar scaffold watch --build-clients`
import * as nonFungible from "non_fungible_contract";

// Wallet hook (shape may vary by lib)
import { useWallet } from "../hooks/useWallet";

/* ---------------------------------- Types --------------------------------- */

type FermentationState = "active" | "monitoring" | "ready";

interface LogEntry {
  id: string; // unique key for React
  date: string;
  state: string;
  notes: string;
}

interface FermentationProduct {
  id: string; // local UI id
  tokenId: number; // on-chain u32 id
  name: string;
  type: string;
  startDate: string;
  currentState: FermentationState;
  progress: number; // 0..100
  metadata: {
    ingredients: string;
    temperature: string;
    notes: string;
  };
  progressLog: LogEntry[];
  minted?: boolean; // UI hint
}

/** Contract methods we may have (scaffold variants differ) */
type MintArgs = { to: string; token_id: number; uri: string; caller?: string };
type SetMetaArgs = { token_id: number; uri: string; caller?: string };
type BurnArgs = { token_id: number; caller?: string; from?: string };

type NftContract = {
  mint?: (args: MintArgs) => Promise<unknown>;
  mint_to?: (args: MintArgs) => Promise<unknown>;
  set_metadata?: (args: SetMetaArgs) => Promise<unknown>;
  set_uri?: (args: SetMetaArgs) => Promise<unknown>;
  burn?: (args: BurnArgs) => Promise<unknown>;
  owner_of?: (args: { token_id: number }) => Promise<unknown>;
  hello?: (args: { to: string }) => Promise<unknown>;
  options?: {
    rpcUrl?: string;
    networkPassphrase?: string;
    allowHttp?: boolean;
  };
};

/* ------------------------------- Util helpers ------------------------------ */

const uid = () => `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

const errorToString = (e: unknown): string => {
  if (e instanceof Error && typeof e.message === "string") return e.message;
  if (typeof e === "string") return e;
  try {
    return JSON.stringify(e);
  } catch {
    return String(e);
  }
};

const isRecord = (v: unknown): v is Record<string, unknown> =>
  typeof v === "object" && v !== null;

const getStringProp = (obj: Record<string, unknown>, key: string): string | undefined => {
  const v = obj[key];
  return typeof v === "string" ? v : undefined;
};

/** Extract a wallet public key / address from several possible shapes */
const extractPublicKey = (wallet: unknown): string | undefined => {
  if (!isRecord(wallet)) return undefined;
  const direct =
    getStringProp(wallet, "publicKey") ??
    getStringProp(wallet, "address") ??
    getStringProp(wallet, "accountId");
  if (direct) return direct;

  const account = isRecord(wallet["account"]) ? (wallet["account"] as Record<string, unknown>) : undefined;
  const accountPk = account ? getStringProp(account, "publicKey") : undefined;
  if (accountPk) return accountPk;

  const session = isRecord(wallet["session"]) ? (wallet["session"] as Record<string, unknown>) : undefined;
  const sessionPk = session ? getStringProp(session, "publicKey") : undefined;
  return sessionPk;
};

/** Build metadata JSON and embed as data: URI (swap to IPFS/Arweave later) */
const makeMetadataURI = (p: FermentationProduct): string => {
  const payload = {
    name: p.name,
    category: p.type,
    progress: p.progress,
    state: p.currentState,
    startedAt: p.startDate,
    attributes: {
      ingredients: p.metadata.ingredients,
      temperature: p.metadata.temperature,
      notes: p.metadata.notes,
    },
    log: p.progressLog,
    updatedAt: new Date().toISOString(),
  };
  return `data:application/json,${encodeURIComponent(JSON.stringify(payload))}`;
};

/** Clamp to u32 for Soroban spec (0..2^32-1) */
const toU32 = (n: number): number => {
  const x = Math.floor(Number.isFinite(n) ? n : 0);
  return Math.min(0xffffffff, Math.max(0, x));
};

/** Create a u32 token id (simple placeholder; swap to server/contract counter later) */
const newTokenId = (): number => toU32(Date.now() % 0x7fffffff);

const todayISO = () => new Date().toISOString().split("T")[0];

/**
 * Patch generated client options to allow local HTTP without touching .env.
 * If rpcUrl or passphrase are missing, read from import.meta.env (Scaffold sets these).
 */
const patchClientOptionsForLocal = <T extends NftContract>(client: T): T => {
  try {
    const env = (import.meta as unknown as { env?: Record<string, string | undefined> }).env || {};
    const rpcEnv =
      env.PUBLIC_STELLAR_RPC_URL ||
      env.PUBLIC_SOROBAN_RPC_URL ||
      env.VITE_PUBLIC_STELLAR_RPC_URL;
    const passEnv =
      env.PUBLIC_STELLAR_NETWORK_PASSPHRASE ||
      env.VITE_PUBLIC_STELLAR_NETWORK_PASSPHRASE;

    if (!client.options) client.options = {};
    if (!client.options.rpcUrl && rpcEnv) client.options.rpcUrl = rpcEnv;
    if (!client.options.networkPassphrase && passEnv) client.options.networkPassphrase = passEnv;
    if (client.options.rpcUrl && client.options.rpcUrl.startsWith("http://")) {
      client.options.allowHttp = true; // local dev convenience
    }
  } catch {
    // best effort
  }
  return client;
};

/** Support both default and named export shapes without using `any` */
const getNftContract = (): NftContract => {
  const mod = nonFungible as unknown as { default?: unknown } & Record<string, unknown>;
  const obj = (mod.default ?? mod) as NftContract;
  return patchClientOptionsForLocal(obj);
};

/**
 * Generic helper: try multiple arg variants for a typed contract method.
 * Useful for templates that require `caller` / `from`.
 */
async function callWithArgVariants<R, A>(
  fn: ((args: A) => Promise<R>) | undefined,
  variants: A[],
): Promise<R | undefined> {
  if (!fn) return undefined;
  let lastErr: unknown;
  for (const args of variants) {
    try {
      // eslint-disable-next-line no-await-in-loop
      return await fn(args);
    } catch (e) {
      lastErr = e;
      const msg = errorToString(e).toLowerCase();
      const isSchemaIssue =
        msg.includes("missing field") ||
        msg.includes("unknown field") ||
        msg.includes("invalid type");
      if (!isSchemaIssue) break;
    }
  }
  throw lastErr;
}

/* ---------------------------------- UI css -------------------------------- */

const stateStyle: Record<FermentationState, { bg: string; fg: string; label: string }> = {
  active: { bg: "#e6f0ff", fg: "#003a8c", label: "active" },
  monitoring: { bg: "#fff7e6", fg: "#ad4e00", label: "monitoring" },
  ready: { bg: "#e6fffb", fg: "#006d75", label: "ready" },
};

const badge = (state: FermentationState) => {
  const s = stateStyle[state];
  return (
    <span
      style={{
        background: s.bg,
        color: s.fg,
        borderRadius: 999,
        padding: "2px 8px",
        fontSize: 12,
        fontWeight: 600,
        textTransform: "capitalize",
        whiteSpace: "nowrap",
      }}
      aria-label={`status: ${s.label}`}
    >
      {s.label}
    </span>
  );
};

const labelCol: React.CSSProperties = { color: "#6b7280", fontSize: 12, fontWeight: 500 };
const cardStyle: React.CSSProperties = { border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, background: "#fff" };
const buttonStyle: React.CSSProperties = { borderRadius: 10, padding: "8px 12px", border: "1px solid #e5e7eb", background: "#fff", cursor: "pointer" };
const primaryButtonStyle: React.CSSProperties = { ...buttonStyle, background: "#1f6feb", color: "#fff", border: "1px solid #1f6feb" };
const inputStyle: React.CSSProperties = { width: "100%", border: "1px solid #e5e7eb", borderRadius: 8, padding: "8px 10px", fontSize: 14 };
const progressTrack: React.CSSProperties = { width: "100%", height: 8, borderRadius: 999, background: "#f3f4f6", overflow: "hidden" };
const progressBar = (value: number): React.CSSProperties => ({ width: `${Math.min(100, Math.max(0, value))}%`, height: "100%", background: "#1f6feb" });
const sectionGap: React.CSSProperties = { display: "grid", gap: 16 };
const smallNote: React.CSSProperties = { color: "#6b7280", fontSize: 12 };
const hrSoft = <hr style={{ border: 0, borderTop: "1px solid #f3f4f6", margin: "12px 0" }} />;

/* ---------------------------------- Seed ---------------------------------- */

const initialSeed: FermentationProduct[] = [
  {
    id: "1",
    tokenId: toU32(1001),
    name: "Sourdough Starter",
    type: "Bread",
    startDate: "2024-01-15",
    currentState: "active",
    progress: 65,
    metadata: { ingredients: "Flour, Water", temperature: "22Â°C", notes: "Daily feeding schedule" },
    progressLog: [
      { id: uid(), date: "2024-01-15", state: "Started", notes: "Initial mix" },
      { id: uid(), date: "2024-01-18", state: "First bubbles", notes: "Activity detected" },
    ],
    minted: false,
  },
  {
    id: "2",
    tokenId: toU32(1002),
    name: "Kimchi Batch #3",
    type: "Vegetable",
    startDate: "2024-01-20",
    currentState: "monitoring",
    progress: 85,
    metadata: { ingredients: "Cabbage, Gochugaru, Salt, Garlic", temperature: "18Â°C", notes: "Extra spicy batch" },
    progressLog: [
      { id: uid(), date: "2024-01-20", state: "Started", notes: "Salted and packed" },
      { id: uid(), date: "2024-01-23", state: "Active fermentation", notes: "Strong sour smell" },
    ],
    minted: false,
  },
];

/* --------------------------------- Component ------------------------------- */

const LS_KEY = "fermentation.products.v1";

const Home: React.FC = () => {
  const wallet = useWallet();
  const walletPublicKey = extractPublicKey(wallet);
  const isConnected = typeof walletPublicKey === "string" && walletPublicKey.length > 0;

  const [products, setProducts] = React.useState<FermentationProduct[]>(initialSeed);
  const [openId, setOpenId] = React.useState<string | null>(null);
  const [isAdding, setIsAdding] = React.useState(false);
  const [mintOnAdd, setMintOnAdd] = React.useState(true);
  const [newProduct, setNewProduct] = React.useState({
    name: "",
    type: "",
    ingredients: "",
    temperature: "",
    notes: "",
  });

  const resetForm = () =>
    setNewProduct({
      name: "",
      type: "",
      ingredients: "",
      temperature: "",
      notes: "",
    });

  // Hydrate from localStorage on first mount
  React.useEffect(() => {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (raw) {
        const parsed = JSON.parse(raw) as FermentationProduct[];
        if (Array.isArray(parsed)) setProducts(parsed);
      }
    } catch {
      // ignore
    }
  }, []);

  // Persist to localStorage on change
  React.useEffect(() => {
    try {
      localStorage.setItem(LS_KEY, JSON.stringify(products));
    } catch {
      // ignore quota errors
    }
  }, [products]);

  // On connect or on product set change, verify ownership of stored tokenIds
  React.useEffect(() => {
    const verify = async () => {
      if (!isConnected) return;
      const c = getNftContract();
      if (typeof c.owner_of !== "function") return; // nothing we can do

      const updated = await Promise.all(
        products.map(async (p) => {
          try {
            const owner = await c.owner_of!({ token_id: p.tokenId });
            let ownerStr: string | undefined;
            if (typeof owner === "string") ownerStr = owner;
            else if (isRecord(owner)) {
              // generated client could return { address: "..." } or similar
              ownerStr =
                getStringProp(owner, "address") ??
                getStringProp(owner, "accountId") ??
                getStringProp(owner, "publicKey");
            }
            const stillOwned = !!ownerStr && ownerStr === walletPublicKey;
            return { ...p, minted: stillOwned ? true : p.minted ?? false };
          } catch {
            // If call fails (burned/not minted), keep as-is
            return p;
          }
        }),
      );

      // Optionally prune entries not owned anymore:
      // const pruned = updated.filter(p => p.minted);
      setProducts(updated);
    };

    void verify();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isConnected, walletPublicKey]);

  /* ---------------------------- On-chain operations --------------------------- */

  const mintProduct = async (p: FermentationProduct): Promise<void> => {
    if (!isConnected || !walletPublicKey) {
      alert("Connect your wallet to mint the product NFT.");
      return;
    }
    const c = getNftContract();
    const uri = makeMetadataURI(p);

    const mintVariants: MintArgs[] = [
      { to: walletPublicKey, token_id: p.tokenId, uri, caller: walletPublicKey },
      { to: walletPublicKey, token_id: p.tokenId, uri },
    ];

    try {
      const tried =
        (await callWithArgVariants(c.mint, mintVariants)) ??
        (await callWithArgVariants(c.mint_to, mintVariants));

      if (!tried) {
        alert("Contract does not expose mint/mint_to; cannot mint on-chain yet.");
        return;
      }

      // Mark minted in UI
      setProducts((prev) =>
        prev.map((x) => (x.id === p.id ? { ...x, minted: true } : x)),
      );
    } catch (err: unknown) {
      console.error(err);
      alert(`Mint failed: ${errorToString(err)}`);
    }
  };

  const updateOnChainMetadata = async (p: FermentationProduct): Promise<void> => {
    if (!isConnected || !walletPublicKey) return;
    const c = getNftContract();
    const uri = makeMetadataURI(p);

    const setMetaVariants: SetMetaArgs[] = [
      { token_id: p.tokenId, uri, caller: walletPublicKey },
      { token_id: p.tokenId, uri },
    ];

    try {
      await callWithArgVariants(c.set_metadata, setMetaVariants);
      await callWithArgVariants(c.set_uri, setMetaVariants);
    } catch (err: unknown) {
      console.warn("Metadata update failed:", err);
    }
  };

  /** P1â†’P2: burn P1 (if supported) then mint P2 */
  const transformProduct = async (productId: string) => {
    const current = products.find((p) => p.id === productId);
    if (!current) return;

    if (!isConnected || !walletPublicKey) {
      alert("Connect your wallet to finalize on-chain.");
      return;
    }

    const c = getNftContract();
    const hasBurn = typeof c.burn === "function";
    const hasMint = typeof c.mint === "function" || typeof c.mint_to === "function";

    if (!hasMint) {
      alert("Contract has no mint method; cannot mint P2.");
      return;
    }

    try {
      if (hasBurn && current.minted) {
        const burnVariants: BurnArgs[] = [
          { token_id: current.tokenId, from: walletPublicKey, caller: walletPublicKey },
          { token_id: current.tokenId, caller: walletPublicKey },
          { token_id: current.tokenId, from: walletPublicKey },
          { token_id: current.tokenId },
        ];
        await callWithArgVariants(c.burn, burnVariants);
      }

      const p2: FermentationProduct = {
        ...current,
        tokenId: toU32(current.tokenId + 1),
        currentState: "ready",
        progress: 100,
        progressLog: [
          ...current.progressLog,
          { id: uid(), date: todayISO(), state: "Transformed to P2 (ready)", notes: "Fermentation completed" },
        ],
        minted: false,
      };
      const uri2 = makeMetadataURI(p2);

      const mintP2Variants: MintArgs[] = [
        { to: walletPublicKey, token_id: p2.tokenId, uri: uri2, caller: walletPublicKey },
        { to: walletPublicKey, token_id: p2.tokenId, uri: uri2 },
      ];

      await (callWithArgVariants(c.mint, mintP2Variants) ??
        callWithArgVariants(c.mint_to, mintP2Variants));

      setProducts((prev) =>
        prev.map((p) => (p.id === productId ? { ...p2, minted: true } : p)),
      );
      alert("ðŸŽ‰ Transformed: P1 burned (if supported) and P2 minted.");
    } catch (err: unknown) {
      console.error(err);
      alert(`On-chain finalize failed: ${errorToString(err)}`);
    }
  };

  /* --------------------------------- Handlers -------------------------------- */

  const addProduct = async () => {
    if (!newProduct.name.trim() || !newProduct.type.trim()) return;

    const prod: FermentationProduct = {
      id: String(Date.now()),
      tokenId: newTokenId(),
      name: newProduct.name.trim(),
      type: newProduct.type.trim(),
      startDate: todayISO(),
      currentState: "active",
      progress: 0,
      metadata: {
        ingredients: newProduct.ingredients.trim(),
        temperature: newProduct.temperature.trim(),
        notes: newProduct.notes.trim(),
      },
      progressLog: [{ id: uid(), date: todayISO(), state: "Started", notes: "Initial fermentation setup" }],
      minted: false,
    };

    setProducts((prev) => [...prev, prod]);
    resetForm();
    setIsAdding(false);

    if (mintOnAdd) {
      await mintProduct(prod);
    }
  };

  const updateProgress = async (productId: string, newProgress: number, notes: string) => {
    let updated: FermentationProduct | undefined;
    setProducts((prev) =>
      prev.map((p) => {
        if (p.id !== productId) return p;
        const pct = Math.max(0, Math.min(100, newProgress));
        const s: FermentationState = pct >= 100 ? "ready" : pct >= 50 ? "monitoring" : "active";
        updated = {
          ...p,
          progress: pct,
          currentState: s,
          progressLog: [...p.progressLog, { id: uid(), date: todayISO(), state: `Progress: ${pct}%`, notes: notes || "" }],
        };
        return updated!;
      }),
    );

    if (updated && updated.minted) await updateOnChainMetadata(updated);
  };

  /* ---------------------------------- Render --------------------------------- */

  return (
    <Layout.Content>
      <Layout.Inset>
        {/* Top bar with logo */}
        <div style={{ display: "flex", alignItems: "center", gap: 12, marginBottom: 12 }}>
          <img src="/logo.png" alt="Fermentation Tracker logo" width={36} height={36} style={{ display: "block", borderRadius: 8 }} />
          <h1 style={{ margin: 0 }}>Fermentation Tracker</h1>
        </div>

        {/* Intro */}
        <div style={{ display: "grid", gap: 12, marginBottom: 24 }}>
          <p style={{ color: "#6b7280" }}>
            Track fermentation from P1 to P2. You can mint an NFT when you add a product, update its metadata as you
            monitor, and on completion burn P1 (if supported) and mint P2 with final attributes.
          </p>
          {!isConnected && (
            <p style={{ color: "#9ca3af", fontStyle: "italic", marginTop: -8 }}>
              Connect your wallet to mint/update on-chain.
            </p>
          )}
        </div>

        {/* Add Product */}
        <div style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, background: "#fff", marginBottom: 16 }}>
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
            <h2 style={{ margin: 0, fontSize: 18 }}>Register New Product</h2>
            <button type="button" style={isAdding ? buttonStyle : primaryButtonStyle} onClick={() => setIsAdding((s) => !s)}>
              {isAdding ? "Close" : "Add product"}
            </button>
          </div>

          {isAdding && (
            <>
              {hrSoft}
              <div style={{ display: "grid", gap: 12 }}>
                <div>
                  <label style={labelCol} htmlFor="name">Product Name</label>
                  <input id="name" style={inputStyle} value={newProduct.name} onChange={(e) => setNewProduct((p) => ({ ...p, name: e.target.value }))} placeholder="e.g., Sourdough Starter" />
                </div>

                <div>
                  <label style={labelCol} htmlFor="type">Type</label>
                  <select id="type" style={inputStyle} value={newProduct.type} onChange={(e) => setNewProduct((p) => ({ ...p, type: e.target.value }))}>
                    <option value="">Select type</option>
                    <option value="Bread">Bread</option>
                    <option value="Vegetable">Vegetable</option>
                    <option value="Dairy">Dairy</option>
                    <option value="Beverage">Beverage</option>
                    <option value="Other">Other</option>
                  </select>
                </div>

                <div>
                  <label style={labelCol} htmlFor="ingredients">Ingredients</label>
                  <input id="ingredients" style={inputStyle} value={newProduct.ingredients} onChange={(e) => setNewProduct((p) => ({ ...p, ingredients: e.target.value }))} placeholder="Main ingredients" />
                </div>

                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12 }}>
                  <div>
                    <label style={labelCol} htmlFor="temperature">Temperature</label>
                    <input id="temperature" style={inputStyle} value={newProduct.temperature} onChange={(e) => setNewProduct((p) => ({ ...p, temperature: e.target.value }))} placeholder="22Â°C" />
                  </div>
                  <div>
                    <label style={labelCol} htmlFor="notes">Notes</label>
                    <input id="notes" style={inputStyle} value={newProduct.notes} onChange={(e) => setNewProduct((p) => ({ ...p, notes: e.target.value }))} placeholder="Free text notes" />
                  </div>
                </div>

                <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                  <input
                    id="mintOnAdd"
                    type="checkbox"
                    checked={mintOnAdd}
                    onChange={(e) => setMintOnAdd(e.target.checked)}
                  />
                  <label htmlFor="mintOnAdd" style={{ fontSize: 14 }}>
                    Mint NFT on add
                  </label>
                </div>

                <button type="button" onClick={() => void addProduct()} style={primaryButtonStyle}>
                  Register Product{mintOnAdd ? " & Mint P1" : ""}
                </button>
              </div>
            </>
          )}
        </div>

        {/* Products List */}
        <div style={sectionGap}>
          {products.map((product) => {
            const open = openId === product.id;
            return (
              <section key={product.id} style={cardStyle} aria-label={product.name}>
                <header style={{ display: "flex", justifyContent: "space-between", alignItems: "center", gap: 8 }}>
                  <div>
                    <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                      <h3 style={{ margin: 0, fontSize: 16 }}>{product.name}</h3>
                      {badge(product.currentState)}
                    </div>
                    <div style={smallNote}>
                      {product.type} â€¢ Started {product.startDate} â€¢ token #{product.tokenId} {product.minted ? "â€¢ on-chain" : "â€¢ local"}
                    </div>
                  </div>
                  <button type="button" style={buttonStyle} onClick={() => setOpenId(open ? null : product.id)}>
                    {open ? "Hide" : "View Details & Update Progress"}
                  </button>
                </header>

                <div style={{ marginTop: 12 }}>
                  <div style={{ display: "flex", justifyContent: "space-between", fontSize: 12, color: "#374151" }}>
                    <span>Progress</span>
                    <span>{product.progress}%</span>
                  </div>
                  <div style={progressTrack} role="progressbar" aria-valuenow={product.progress} aria-valuemin={0} aria-valuemax={100}>
                    <div style={progressBar(product.progress)} />
                  </div>
                </div>

                {open && (
                  <>
                    {hrSoft}
                    <div style={{ display: "grid", gap: 16 }}>
                      {/* Details */}
                      <div style={{ display: "grid", gridTemplateColumns: "repeat(2, minmax(0, 1fr))", gap: 12 }}>
                        <div><div style={labelCol}>Type</div><div>{product.type}</div></div>
                        <div><div style={labelCol}>Started</div><div>{product.startDate}</div></div>
                        <div><div style={labelCol}>Temperature</div><div>{product.metadata.temperature}</div></div>
                      </div>

                      <div><div style={labelCol}>Ingredients</div><div style={{ fontSize: 14 }}>{product.metadata.ingredients}</div></div>
                      <div><div style={labelCol}>Notes</div><div style={{ fontSize: 14 }}>{product.metadata.notes}</div></div>

                      {/* Progress Controls */}
                      <div>
                        <div style={{ ...labelCol, marginBottom: 8 }}>Update Progress</div>
                        <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
                          <button type="button" style={buttonStyle} onClick={() => void updateProgress(product.id, product.progress + 10, "Progress update")}>+10%</button>
                          <button type="button" style={buttonStyle} onClick={() => void updateProgress(product.id, product.progress + 25, "Significant progress")}>+25%</button>
                          <button type="button" style={buttonStyle} onClick={() => void updateProgress(product.id, 100, "Fermentation complete")}>Complete</button>
                        </div>
                      </div>

                      {/* Progress Log */}
                      <div>
                        <div style={{ ...labelCol, marginBottom: 8 }}>Progress Log</div>
                        <div style={{ display: "grid", gap: 8, maxHeight: 180, overflowY: "auto" }}>
                          {product.progressLog.map((log) => (
                            <div key={log.id} style={{ background: "#f9fafb", border: "1px solid #f3f4f6", borderRadius: 8, padding: 8, fontSize: 13 }}>
                              <div style={{ fontWeight: 600 }}>{log.date}</div>
                              <div style={{ color: "#6b7280" }}>{log.state}</div>
                              {log.notes && <div style={{ fontSize: 12 }}>{log.notes}</div>}
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* On-chain finalize (P1 -> P2) */}
                      {product.currentState === "ready" && (
                        <button
                          type="button"
                          onClick={() => void transformProduct(product.id)}
                          style={primaryButtonStyle}
                          title="Burn P1 (if supported) and mint P2 with final metadata"
                        >
                          Transform Product (P1 â†’ P2)
                        </button>
                      )}
                    </div>
                  </>
                )}
              </section>
            );
          })}

          {products.length === 0 && (
            <div style={{ ...cardStyle, textAlign: "center" }}>
              <div style={{ color: "#6b7280", marginBottom: 4 }}>No fermentations yet</div>
              <div style={{ ...smallNote }}>Register your first product to get started</div>
            </div>
          )}
        </div>
      </Layout.Inset>
    </Layout.Content>
  );
};

export default Home;
